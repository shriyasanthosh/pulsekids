export class AdvancedPPGProcessor {
  constructor() {
    this.sampleRate = 30;
    this.bufferSize = 900; // 30 seconds at 30fps
    this.minHeartRate = 60;  // Children can have higher HR
    this.maxHeartRate = 200; // Children under 7 can have HR up to 200
    
    this.redBuffer = [];
    this.greenBuffer = [];
    this.blueBuffer = [];
    this.timestamps = [];
    this.heartRateHistory = [];
    this.bpHistory = [];
    
    this.measurementStartTime = null;
    this.temperature = 37; // Default body temperature
    this.childAge = 5; // Default age for children
  }

  setTemperature(temp) {
    this.temperature = Math.max(35, Math.min(42, temp)); // 35-42Â°C range
  }

  setChildAge(age) {
    this.childAge = Math.max(0, Math.min(7, age)); // 0-7 years
  }

  async processFrame(imageUri, timestamp) {
    try {
      // Extract RGB values from camera frame
      const rgbValues = await this.extractRGBFromImage(imageUri);
      
      if (!rgbValues) return null;
      
      this.addToBuffer(rgbValues, timestamp);
      
      if (this.redBuffer.length >= 90) { // 3 seconds minimum
        return this.calculateVitalSigns();
      }
      
      return null;
    } catch (error) {
      console.error('Frame processing error:', error);
      return null;
    }
  }

  async extractRGBFromImage(imageUri) {
    // In React Native, we need to use a native module or Canvas API
    // For now, implementing a simulation that mimics real PPG signal
    
    const timestamp = Date.now();
    if (!this.measurementStartTime) {
      this.measurementStartTime = timestamp;
    }
    
    const elapsed = (timestamp - this.measurementStartTime) / 1000;
    
    // Adjust base heart rate for children (higher than adults)
    const baseHR = this.getChildBaseHeartRate() + Math.sin(elapsed / 10) * 15;
    const cardiacFreq = baseHR / 60;
    
    // Primary cardiac signal (systolic peak)
    const systolic = Math.sin(2 * Math.PI * cardiacFreq * elapsed);
    
    // Dicrotic notch (aortic valve closure)
    const dicrotic = 0.4 * Math.sin(2 * Math.PI * cardiacFreq * elapsed + Math.PI * 0.6);
    
    // Respiratory modulation (children breathe faster)
    const respiratory = 0.2 * Math.sin(2 * Math.PI * 0.4 * elapsed);
    
    // Vascular compliance effects (children have more compliant vessels)
    const compliance = 0.15 * Math.sin(2 * Math.PI * cardiacFreq * elapsed + Math.PI);
    
    // Temperature effects on vascular tone
    const tempEffect = this.calculateTemperatureEffect();
    
    // Combine signals
    const ppgSignal = (systolic + dicrotic + respiratory + compliance) * tempEffect;
    
    // Add realistic noise
    const noise = 0.05 * (Math.random() - 0.5);
    
    // Convert to RGB values (green channel most sensitive to blood volume changes)
    return {
      red: 128 + 20 * ppgSignal + 8 * noise,
      green: 128 + 35 * ppgSignal + 4 * noise,
      blue: 128 + 15 * ppgSignal + 12 * noise,
      timestamp: timestamp
    };
  }

  getChildBaseHeartRate() {
    // Age-adjusted heart rate for children under 7
    if (this.childAge <= 1) return 120;      // 0-1 years: 120-160 BPM
    if (this.childAge <= 3) return 110;      // 1-3 years: 110-150 BPM
    if (this.childAge <= 5) return 100;      // 3-5 years: 100-140 BPM
    if (this.childAge <= 7) return 90;       // 5-7 years: 90-130 BPM
    return 85; // Default
  }

  calculateTemperatureEffect() {
    // Temperature affects vascular tone and heart rate
    if (this.temperature < 36) return 0.8;  // Cold: vasoconstriction
    if (this.temperature > 38) return 1.2;  // Fever: vasodilation
    return 1.0; // Normal temperature
  }

  addToBuffer(rgbValues, timestamp) {
    this.redBuffer.push(rgbValues.red);
    this.greenBuffer.push(rgbValues.green);
    this.blueBuffer.push(rgbValues.blue);
    this.timestamps.push(timestamp);

    while (this.redBuffer.length > this.bufferSize) {
      this.redBuffer.shift();
      this.greenBuffer.shift();
      this.blueBuffer.shift();
      this.timestamps.shift();
    }
  }

  calculateVitalSigns() {
    const signal = [...this.greenBuffer];
    
    // Advanced signal processing
    const filtered = this.advancedFilter(signal);
    const normalized = this.normalizeSignal(filtered);
    
    // Calculate heart rate
    const heartRate = this.calculateHeartRate(normalized);
    
    // Calculate blood pressure using pulse wave analysis
    const bloodPressure = this.calculateBloodPressure(normalized, heartRate);
    
    // Calculate confidence
    const confidence = this.calculateConfidence(normalized, heartRate);
    
    // Assess signal quality
    const quality = this.assessSignalQuality(normalized, confidence);
    
    return {
      heartRate: heartRate,
      bloodPressure: bloodPressure,
      confidence: confidence,
      quality: quality,
      signalData: this.getDisplaySignal(normalized),
      temperature: this.temperature,
      childAge: this.childAge,
      isValid: heartRate >= this.minHeartRate && heartRate <= this.maxHeartRate
    };
  }

  advancedFilter(signal) {
    // Multi-stage filtering optimized for children's signals
    let filtered = this.butterworthFilter(signal, 0.8, 8.0); // Higher frequency range for children
    filtered = this.movingAverageFilter(filtered, 3);
    filtered = this.savitzkyGolayFilter(filtered);
    
    return filtered;
  }

  butterworthFilter(signal, lowCut, highCut) {
    // Simplified Butterworth implementation
    const nyquist = this.sampleRate / 2;
    const low = lowCut / nyquist;
    const high = highCut / nyquist;
    
    // High-pass filter (remove DC component)
    let filtered = this.highPassFilter(signal, low);
    
    // Low-pass filter (remove high-frequency noise)
    filtered = this.lowPassFilter(filtered, high);
    
    return filtered;
  }

  highPassFilter(signal, cutoff) {
    const alpha = cutoff / (cutoff + 1);
    const filtered = [signal[0]];
    
    for (let i = 1; i < signal.length; i++) {
      filtered[i] = alpha * (filtered[i-1] + signal[i] - signal[i-1]);
    }
    
    return filtered;
  }

  lowPassFilter(signal, cutoff) {
    const alpha = cutoff;
    const filtered = [signal[0]];
    
    for (let i = 1; i < signal.length; i++) {
      filtered[i] = alpha * signal[i] + (1 - alpha) * filtered[i-1];
    }
    
    return filtered;
  }

  movingAverageFilter(signal, windowSize) {
    const filtered = [];
    
    for (let i = 0; i < signal.length; i++) {
      let sum = 0;
      let count = 0;
      
      for (let j = Math.max(0, i - windowSize); j <= Math.min(signal.length - 1, i + windowSize); j++) {
        sum += signal[j];
        count++;
      }
      
      filtered[i] = sum / count;
    }
    
    return filtered;
  }

  savitzkyGolayFilter(signal) {
    // Simplified Savitzky-Golay filter for smoothing
    if (signal.length < 5) return signal;
    
    const filtered = [...signal];
    const coeffs = [-3, 12, 17, 12, -3]; // 5-point quadratic
    const norm = 35;
    
    for (let i = 2; i < signal.length - 2; i++) {
      let sum = 0;
      for (let j = 0; j < coeffs.length; j++) {
        sum += coeffs[j] * signal[i - 2 + j];
      }
      filtered[i] = sum / norm;
    }
    
    return filtered;
  }

  calculateHeartRate(signal) {
    // Advanced peak detection with multiple validation methods
    const peaks = this.findValidatedPeaks(signal);
    
    if (peaks.length < 3) return null;
    
    // Calculate RR intervals
    const intervals = [];
    for (let i = 1; i < peaks.length; i++) {
      const intervalSamples = peaks[i] - peaks[i-1];
      const intervalSeconds = intervalSamples / this.sampleRate;
      intervals.push(60 / intervalSeconds);
    }
    
    // Remove outliers and calculate median
    const cleanedIntervals = this.removeOutliers(intervals);
    if (cleanedIntervals.length === 0) return null;
    
    const medianHR = this.calculateMedian(cleanedIntervals);
    
    // Add to history and return smoothed value
    this.heartRateHistory.push(medianHR);
    if (this.heartRateHistory.length > 15) {
      this.heartRateHistory.shift();
    }
    
    return Math.round(this.calculateMedian(this.heartRateHistory.slice(-5)));
  }

  findValidatedPeaks(signal) {
    // Multi-criteria peak detection optimized for children
    const peaks = [];
    const threshold = this.calculateAdaptiveThreshold(signal);
    const minPeakDistance = Math.floor(this.sampleRate * 0.3); // 300ms minimum for children
    
    // First pass: basic peak detection
    for (let i = 1; i < signal.length - 1; i++) {
      if (signal[i] > signal[i-1] && 
          signal[i] > signal[i+1] && 
          signal[i] > threshold) {
        peaks.push(i);
      }
    }
    
    // Second pass: validate peaks
    const validatedPeaks = [];
    peaks.forEach(peak => {
      if (validatedPeaks.length === 0 || 
          peak - validatedPeaks[validatedPeaks.length - 1] >= minPeakDistance) {
        
        // Additional validation criteria
        if (this.validatePeak(signal, peak)) {
          validatedPeaks.push(peak);
        }
      }
    });
    
    return validatedPeaks;
  }

  validatePeak(signal, peakIndex) {
    const windowSize = 5;
    const start = Math.max(0, peakIndex - windowSize);
    const end = Math.min(signal.length - 1, peakIndex + windowSize);
    
    // Check if peak is highest in local window
    for (let i = start; i <= end; i++) {
      if (i !== peakIndex && signal[i] >= signal[peakIndex]) {
        return false;
      }
    }
    
    // Check peak prominence
    const prominence = this.calculatePeakProminence(signal, peakIndex);
    return prominence > 0.1; // Minimum prominence threshold
  }

  calculatePeakProminence(signal, peakIndex) {
    // Simplified prominence calculation
    const peakValue = signal[peakIndex];
    const windowSize = 10;
    
    let minLeft = peakValue;
    let minRight = peakValue;
    
    // Find minimum to the left
    for (let i = Math.max(0, peakIndex - windowSize); i < peakIndex; i++) {
      minLeft = Math.min(minLeft, signal[i]);
    }
    
    // Find minimum to the right  
    for (let i = peakIndex + 1; i <= Math.min(signal.length - 1, peakIndex + windowSize); i++) {
      minRight = Math.min(minRight, signal[i]);
    }
    
    return peakValue - Math.max(minLeft, minRight);
  }

  calculateBloodPressure(signal, heartRate) {
    if (!heartRate || signal.length < 150) {
      return { systolic: null, diastolic: null };
    }
    
    // Pulse Wave Analysis for BP estimation (adjusted for children)
    const pulseWaveFeatures = this.extractPulseWaveFeatures(signal);
    
    // Estimate systolic BP using pulse wave velocity and amplitude
    const systolic = this.estimateSystolicBP(pulseWaveFeatures, heartRate);
    
    // Estimate diastolic BP using dicrotic notch analysis
    const diastolic = this.estimateDiastolicBP(pulseWaveFeatures, systolic);
    
    // Add to history for smoothing
    const bp = { systolic: Math.round(systolic), diastolic: Math.round(diastolic) };
    this.bpHistory.push(bp);
    
    if (this.bpHistory.length > 10) {
      this.bpHistory.shift();
    }
    
    // Return smoothed values
    return this.getSmoothedBP();
  }

  extractPulseWaveFeatures(signal) {
    const peaks = this.findValidatedPeaks(signal);
    if (peaks.length < 2) return null;
    
    const features = {
      peakAmplitudes: [],
      pulseWidths: [],
      upstrokeTime: [],
      downstrokeTime: [],
      dicrotricNotch: []
    };
    
    peaks.forEach(peakIndex => {
      // Extract features around each peak
      const windowStart = Math.max(0, peakIndex - 30);
      const windowEnd = Math.min(signal.length - 1, peakIndex + 60);
      const waveform = signal.slice(windowStart, windowEnd);
      
      features.peakAmplitudes.push(signal[peakIndex]);
      
      // Calculate pulse width at half maximum
      const halfMax = signal[peakIndex] / 2;
      let leftHalf = peakIndex, rightHalf = peakIndex;
      
      while (leftHalf > windowStart && signal[leftHalf] > halfMax) leftHalf--;
      while (rightHalf < windowEnd && signal[rightHalf] > halfMax) rightHalf++;
      
      features.pulseWidths.push((rightHalf - leftHalf) / this.sampleRate);
      
      // Find dicrotic notch (secondary peak in downstroke)
      const downstrokeStart = peakIndex + 5;
      const downstrokeEnd = Math.min(windowEnd, peakIndex + 40);
      
      if (downstrokeEnd > downstrokeStart) {
        const downstroke = signal.slice(downstrokeStart, downstrokeEnd);
        const dicrotricIndex = this.findSecondaryPeak(downstroke);
        
        if (dicrotricIndex !== -1) {
          features.dicrotricNotch.push(downstroke[dicrotricIndex]);
        }
      }
    });
    
    return features;
  }

  findSecondaryPeak(waveform) {
    if (waveform.length < 5) return -1;
    
    let maxIndex = -1;
    let maxValue = -Infinity;
    
    // Look for secondary peak (dicrotic notch)
    for (let i = 1; i < waveform.length - 1; i++) {
      if (waveform[i] > waveform[i-1] && 
          waveform[i] > waveform[i+1] && 
          waveform[i] > maxValue) {
        maxValue = waveform[i];
        maxIndex = i;
      }
    }
    
    return maxIndex;
  }

  estimateSystolicBP(features, heartRate) {
    if (!features || features.peakAmplitudes.length === 0) {
      // Age-adjusted default estimates for children
      if (this.childAge <= 1) return 85;      // 0-1 years
      if (this.childAge <= 3) return 90;      // 1-3 years
      if (this.childAge <= 5) return 95;      // 3-5 years
      if (this.childAge <= 7) return 100;     // 5-7 years
      return 95; // Default
    }
    
    const avgAmplitude = features.peakAmplitudes.reduce((a, b) => a + b) / features.peakAmplitudes.length;
    const avgPulseWidth = features.pulseWidths.reduce((a, b) => a + b) / features.pulseWidths.length;
    
    // Empirical formula adjusted for children
    let systolic = this.getChildBaseSystolic() + (avgAmplitude * 0.6) + (heartRate * 0.25) - (avgPulseWidth * 150);
    
    // Apply physiological constraints for children
    systolic = Math.max(70, Math.min(140, systolic));
    
    return systolic;
  }

  getChildBaseSystolic() {
    // Age-adjusted systolic BP baseline for children
    if (this.childAge <= 1) return 80;      // 0-1 years: 70-90 mmHg
    if (this.childAge <= 3) return 85;      // 1-3 years: 75-95 mmHg
    if (this.childAge <= 5) return 90;      // 3-5 years: 80-100 mmHg
    if (this.childAge <= 7) return 95;      // 5-7 years: 85-105 mmHg
    return 90; // Default
  }

  estimateDiastolicBP(features, systolic) {
    if (!features || features.dicrotricNotch.length === 0) {
      return systolic * 0.65; // Default ratio for children
    }
    
    const avgDicrotic = features.dicrotricNotch.reduce((a, b) => a + b) / features.dicrotricNotch.length;
    
    // Estimate diastolic based on dicrotic notch characteristics
    let diastolic = 50 + (avgDicrotic * 0.4) + (systolic * 0.12);
    
    // Apply physiological constraints for children
    diastolic = Math.max(40, Math.min(systolic - 25, diastolic));
    
    return diastolic;
  }

  getSmoothedBP() {
   if (this.bpHistory.length === 0) {
     return { systolic: null, diastolic: null };
   }
   
   const recent = this.bpHistory.slice(-3);
   const avgSystolic = recent.reduce((sum, bp) => sum + bp.systolic, 0) / recent.length;
   const avgDiastolic = recent.reduce((sum, bp) => sum + bp.diastolic, 0) / recent.length;
   
   return {
     systolic: Math.round(avgSystolic),
     diastolic: Math.round(avgDiastolic)
   };
 }

 calculateAdaptiveThreshold(signal) {
   const sorted = [...signal].sort((a, b) => a - b);
   const q75 = sorted[Math.floor(sorted.length * 0.75)];
   const q25 = sorted[Math.floor(sorted.length * 0.25)];
   
   return q25 + (q75 - q25) * 0.6;
 }

 removeOutliers(data) {
   if (data.length < 3) return data;
   
   const sorted = [...data].sort((a, b) => a - b);
   const q1 = sorted[Math.floor(sorted.length * 0.25)];
   const q3 = sorted[Math.floor(sorted.length * 0.75)];
   const iqr = q3 - q1;
   
   const lowerBound = q1 - 1.5 * iqr;
   const upperBound = q3 + 1.5 * iqr;
   
   return data.filter(val => val >= lowerBound && val <= upperBound);
 }

 calculateMedian(array) {
   const sorted = [...array].sort((a, b) => a - b);
   const middle = Math.floor(sorted.length / 2);
   
   return sorted.length % 2 === 0
     ? (sorted[middle - 1] + sorted[middle]) / 2
     : sorted[middle];
 }

 calculateConfidence(signal, heartRate) {
   if (!heartRate || signal.length < 60) return 0;
   
   // Multiple confidence factors
   const snr = this.calculateSNR(signal);
   const stability = this.calculateStability();
   const amplitude = this.calculateAmplitude(signal);
   const peakQuality = this.assessPeakQuality(signal);
   
   // Weighted combination
   const snrScore = Math.min(1, Math.max(0, snr / 15));
   const stabilityScore = Math.max(0, 1 - stability / 15);
   const amplitudeScore = Math.min(1, amplitude / 40);
   const peakScore = peakQuality;
   
   return (snrScore * 0.3 + stabilityScore * 0.3 + amplitudeScore * 0.2 + peakScore * 0.2);
 }

 calculateSNR(signal) {
   const signalPower = signal.reduce((sum, val) => sum + val * val, 0) / signal.length;
   
   // Estimate noise as high-frequency components
   const noise = [];
   for (let i = 1; i < signal.length - 1; i++) {
     const smoothed = (signal[i-1] + signal[i] + signal[i+1]) / 3;
     noise.push(signal[i] - smoothed);
   }
   
   const noisePower = noise.reduce((sum, val) => sum + val * val, 0) / noise.length;
   
   return noisePower > 0 ? 10 * Math.log10(signalPower / noisePower) : 20;
 }

 calculateStability() {
   if (this.heartRateHistory.length < 3) return 20;
   
   const recent = this.heartRateHistory.slice(-5);
   const mean = recent.reduce((sum, val) => sum + val, 0) / recent.length;
   const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recent.length;
   
   return Math.sqrt(variance);
 }

 calculateAmplitude(signal) {
   return Math.max(...signal) - Math.min(...signal);
 }

 assessPeakQuality(signal) {
   const peaks = this.findValidatedPeaks(signal);
   if (peaks.length < 2) return 0;
   
   let qualityScore = 0;
   let validPeaks = 0;
   
   peaks.forEach(peakIndex => {
     const prominence = this.calculatePeakProminence(signal, peakIndex);
     const sharpness = this.calculatePeakSharpness(signal, peakIndex);
     
     if (prominence > 0.1 && sharpness > 0.05) {
       qualityScore += (prominence + sharpness) / 2;
       validPeaks++;
     }
   });
   
   return validPeaks > 0 ? qualityScore / validPeaks : 0;
 }

 calculatePeakSharpness(signal, peakIndex) {
   if (peakIndex < 2 || peakIndex >= signal.length - 2) return 0;
   
   const peak = signal[peakIndex];
   const left2 = signal[peakIndex - 2];
   const right2 = signal[peakIndex + 2];
   
   return peak - (left2 + right2) / 2;
 }

 normalizeSignal(signal) {
   if (signal.length === 0) return [];
   
   const mean = signal.reduce((sum, val) => sum + val, 0) / signal.length;
   const std = Math.sqrt(signal.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / signal.length);
   
   return std > 0 ? signal.map(val => (val - mean) / std) : signal.map(() => 0);
 }

 assessSignalQuality(signal, confidence) {
   if (confidence > 0.85) return 'excellent';
   if (confidence > 0.70) return 'good';
   if (confidence > 0.50) return 'fair';
   return 'poor';
 }

 getDisplaySignal(signal) {
   const displayLength = Math.min(90, signal.length);
   const data = signal.slice(-displayLength);
   
   if (data.length === 0) return [];
   
   return data.map((value, index) => ({
     x: index,
     y: value
   }));
 }

 reset() {
   this.redBuffer = [];
   this.greenBuffer = [];
   this.blueBuffer = [];
   this.timestamps = [];
   this.heartRateHistory = [];
   this.bpHistory = [];
   this.measurementStartTime = null;
 }
}
